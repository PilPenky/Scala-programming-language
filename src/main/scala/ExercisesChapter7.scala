package com.horstmann.impatient

import ForTest.ForExercisesChapter7ex1.{Another, AnotherTwo}

import scala.io.StdIn


object ExercisesChapter7 extends App {
  /*
  1. Напишите программу, на примере которой можно убедиться, что
  package com.horstmann.impatient
    не то же самое, что и
  package com
  package horstmann
  package impatient
  */
  println("Задание 1:")

  object Ex1 {
    AnotherTwo.AnotherTwo(args) // Вызов метода из com.horstmann.impatient
    Another.greet() // Вызов метода из com.horstmann.impatient.Another
  }

  val ex1 = Ex1

  ex1
  /*
  Объяснение:
    package com.horstmann.impatient: Это определение пакета, которое создает пакет impatient внутри пакета horstmann, который, в свою очередь, находится внутри пакета com.
    Все классы и объекты, определенные в этом пакете, будут доступны через полное имя com.horstmann.impatient.

    package com
    package horstmann
    package impatient
    Это определение пакетов, которое создает отдельные пакеты. Пакеты не связаны между собой в иерархическом смысле.
  */

  /*
  2. Напишите головоломку, которая смогла бы сбить с толку ваших коллег, программистов на Scala, использующую пакет com, не являющийся пакетом верхнего уровня.
  */
  println()
  println("Задание 2:")
  /*
  Писать ну буду, объясненю:
    Программа не будет компилироваться, т.к. компилятор будет безуспешно пытаться отыскать имя класса внутри пакета другого com.
  */

  /*
  3. Напишите пакет random с функциями nextInt(): Int, nextDouble(): Double и setSeed(seed: Int): Unit.
  Для генерации случайных чисел используйте линейный конгруэнтный генератор
      next = (previous × a + b) mod 2n,
  где a = 1664525, b = 1013904223 и n = 32, а начальное значение previous определяется аргументом seed.
  */
  println()
  println("Задание 3:")

  import ForTest.ForExercisesChapter7ex3.random.random.Random

  val ff = Random

  /*
  4. Как вы думаете, почему создатели языка Scala реализовали синтаксис объектов пакетов, вместо того чтобы просто разрешить добавлять функции и переменные в пакет?
  */
  println()
  println("Задание 4:")
  /*
  Создатели языка Scala реализовали синтаксис объектов пакетов для обеспечения более строгой организации кода и улучшения управления пространством имен.
  Вот несколько причин, почему это было сделано:
    - Инкапсуляция: Объекты и классы в Scala позволяют инкапсулировать данные и методы, что способствует лучшему управлению состоянием и поведением.
      Это помогает избежать конфликтов имен и делает код более читаемым и поддерживаемым.
    - Функциональное программирование: Scala сочетает в себе функциональное и объектно-ориентированное программирование.
      Синтаксис объектов пакетов позволяет создавать функции и методы, которые могут быть связаны с конкретными классами или объектами, что улучшает выразительность кода.
    - Упрощение работы с библиотеками: Объекты пакетов позволяют организовывать код в модули, что упрощает использование и интеграцию сторонних библиотек.
      Это также облегчает повторное использование кода.
    - Поддержка объектно-ориентированного программирования: Scala поддерживает объектно-ориентированное программирование, и синтаксис объектов пакетов позволяет создавать
      более сложные структуры, такие как наследование и полиморфизм.
  */

  /*
  5. Что означает определение private[com] def giveRaise(rate:Double)? Есть ли в этом смысл?
  */
  println()
  println("Задание 5:")
  /*
  Данное определение означает, что метод giveRaise доступен только внутри класса, в котором он определен, и также доступен для всех классов и объектов, находящихся в пакете com и его подпаках.
  Использование private[com] имеет смысл, когда нужно ограничить доступ к методу, но при этом предоставить доступ другим классам в определенном пакете.
  */

  /*
  6. Напишите программу, копирующую все элементы из Java-хеша в Scala-хеш. Используйте операцию импортирования для переименования обоих классов.
  */
  println()
  println("Задание 6:")

  object Ex6 {

    import java.util.{HashMap => JavaHashMap}
    import scala.collection.mutable.{HashMap => ScalaHashMap}

    // Создаем Java-хеш
    val javaHashMap = new JavaHashMap[String, Int]()
    javaHashMap.put("Bob", 30)
    javaHashMap.put("Alice", 25)

    // Создаем Scala-хеш
    val scalaHashMap = ScalaHashMap[String, Int]()

    // Копируем элементы из Java-хеша в Scala-хеш
    for (entry <- javaHashMap.entrySet().toArray) {
      val javaEntry = entry.asInstanceOf[java.util.Map.Entry[String, Int]]
      scalaHashMap.put(javaEntry.getKey, javaEntry.getValue)
    }

    // Выводим содержимое Scala-хеша
    println("Содержимое Scala-хеша:")
    scalaHashMap.foreach { case (key, value) => println(s"$key: $value") }

  }

  val ex6 = Ex6
  ex6

  /*
  7. В предыдущем упражнении перенесите все инструкции import в самую внутреннюю область видимости, насколько это возможно.
  */
  println()
  println("Задание 7:")

  /*
  8. Опишите эффект следующих инструкций:
      import java._
      import javax._
  Насколько правильно это решение?
  */
  println()
  println("Задание 8:")
  /*
  import java._:
    - Импортирует все классы из пакета java, включая такие классы, как java.lang.String, java.util.HashMap, java.io.File и многие другие.
    - Это может быть удобно, если вы планируете использовать много классов из Java, так как вам не нужно будет писать полные имена классов.

  import javax._:
    - Импортирует все классы из пакета javax, который содержит расширения для стандартной библиотеки Java, такие как javax.swing (для графического интерфейса), javax.servlet
      (для веб-приложений) и другие.
    - Как и в случае с java._, это упрощает использование классов из этого пакета.

  Насколько правильно это решение?
  Преимущества:
    - Упрощает код, так как не нужно указывать полные имена классов.
    - Удобно для быстрого доступа к множеству классов, особенно в небольших скриптах или проектах.
  Недостатки:
    - Может привести к конфликтам имен, если в вашем коде есть классы с теми же именами, что и в импортируемых пакетах.
    - Увеличивает область видимости, что может затруднить понимание, откуда берутся определенные классы, особенно в больших проектах.
    - Может ухудшить читаемость кода, так как не всегда очевидно, какие классы используются из импортированных пакетов.

  В общем, использование import java._ и import javax._ может быть оправдано в небольших проектах или в случаях, когда вы уверены, что не столкнетесь с конфликтами имен.
  Однако в больших проектах или в коде, который будет использоваться другими разработчиками, лучше явно импортировать только те классы, которые вам нужны, чтобы избежать путаницы и конфликтов.
  */

  /*
  9. Напишите программу, импортирующую класс java.lang.System, читающую имя пользователя из системного свойства user.name,
  пароль из объекта Console и выводящую сообщение в стандартный поток ошибок, если пароль недостаточно «секретный».
  В противном случае программа должна вывести приветствие в стандартный поток вывода.
  Не импортируйте ничего другого и не используйте полных квалифицированных имен (с точками).
  */
  println()
  println("Задание 9:")

  object Ex9 {

    import java.lang.System

    val username = System.getProperty("user.name")

    println("Введите пароль: ")
    private var password = StdIn.readLine()

    private var passwordString = password.mkString

    while (isPasswordSecret(passwordString) == false) {
      System.err.println("Пароль недостаточно секретный. Пожалуйста, выберите более надежный пароль.")
      password = StdIn.readLine()
      passwordString = password.mkString
      isPasswordSecret(passwordString)
    }
    println(s"Добро пожаловать, $username!")

  }

  def isPasswordSecret(password: String): Boolean = {
    password.length >= 8 && password.exists(_.isDigit)
  }

  val ex9 = Ex9
  ex9

  /*
  10. Помимо StringBuilder, какие другие члены пакета java.lang переопределяют пакет scala?
  */
  println()
  println("Задание 10:")
/*
В Scala существует множество классов и членов, которые переопределяют или оборачивают классы из пакета java.lang. Вот некоторые из них:
  - String: В Scala строка представлена классом scala.Predef.String, который является синонимом java.lang.String.
    Однако Scala добавляет множество методов для работы со строками, которые делают их более удобными для использования.

  - Integer, Long, Double и другие числовые типы: В Scala есть свои обертки для примитивных типов, такие как scala.Int, scala.Long, scala.Double и т.д.
    Эти классы предоставляют дополнительные методы и функциональность по сравнению с их Java-эквивалентами.

  - List, Set, Map: Эти коллекции в Scala являются более мощными и функциональными по сравнению с аналогичными коллекциями в Java.
  Например, scala.List и scala.Set предоставляют множество методов для работы с коллекциями, которые отсутствуют в java.util.List и java.util.Set.

  - Option: В Scala есть класс scala.Option, который представляет собой контейнер, который может содержать значение или быть пустым.
  Это аналогично java.util.Optional, но с более удобным синтаксисом и функциональностью.

  - Tuple: Кортежи в Scala (например, Tuple2, Tuple3 и т.д.) позволяют группировать несколько значений в одном объекте, что не имеет прямого аналога в Java.

  - Any, AnyVal, AnyRef: Эти классы в Scala представляют собой иерархию типов, которая позволяет работать с любыми значениями и ссылочными типами, что отличается от системы типов в Java.

  - Exception: В Scala есть свои классы для обработки исключений, такие как scala.Exception, которые могут быть использованы вместо java.lang.Exception.

  - System: Хотя java.lang.System доступен в Scala, Scala предоставляет дополнительные функции и методы, которые могут упростить работу с системными свойствами и вводом/выводом.
*/
}